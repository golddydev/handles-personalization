spending handles_personalization

enum Redeemer {
    PERSONALIZE { 
        handle: String
        designer: Map[String]Data
    }
    MIGRATE { 
        handle: String
    }
    RESET { 
        handle: String
    }
    RETURN_TO_SENDER
}

struct PzSettings {
    treasury_fee: Int
    treasury_cred: ByteArray
    pz_min_fee: Int
    pz_providers: Map[ByteArray]ByteArray
    valid_contracts: []ByteArray
    admin_creds: []ByteArray
    settings_cred: ByteArray
}

enum Datum {
    CIP68 {
        nft: Map[String]Data
        version: Int
        extra: Data
    }
}

func get_extra(extra: Data) -> Map[String]Data {
    extra.switch {
        Map[Data]Data => Map[String]Data::from_data(extra),
        (Int, fields: []Data) => {
            if (fields.length == 0) {
                Map[String]Data{}
            } else {
                Map[String]Data::from_data(extra)
            }
        },
        _ => Map[String]Data{}
    }
}

func get_datum(output_datum: OutputDatum, ctx: ScriptContext) -> Data {
    output_datum.switch{
        hash: Hash => {
            ctx.tx.datums.get(hash.hash)
        },
        inline: Inline => {
            inline.data
        },
        _ => OutputDatum::new_inline(#).data
    }

}

const HANDLE_HASH: ByteArray = #f0ff48bbb7bbe9d59a40f1ce90e9e9d0ff5002ec48f232b49ca0fb9a
const HANDLE_POLICY: MintingPolicyHash = MintingPolicyHash::new(HANDLE_HASH)
const LBL_444: ByteArray = #001bc280 // (444)bigirishlion
const LBL_222: ByteArray = #000de140 // (222)bigirishlion
const LBL_100: ByteArray = #000643b0 // (100)bigirishlion
const PZ_HANDLE: AssetClass = AssetClass::new(HANDLE_POLICY, LBL_222 + ("pz_settings".encode_utf8()))

func holderAddressesMatch(address1: Address, address2: Address) -> Bool {
    //print(address1.to_hex() + " == " + address2.to_hex());
    if (address1.staking_credential == Option[StakingCredential]::None || address2.staking_credential == Option[StakingCredential]::None) {
        address1.credential == address2.credential
    }
    else {
        address1.staking_credential == address2.staking_credential
    }
}

func policyAndAssetSearch(output: TxOutput, policy: MintingPolicyHash, name: ByteArray, amount: Int, starts_with: Bool) -> Option[AssetClass] {
    output.value.to_map().fold_lazy((key: MintingPolicyHash, value: Map[ByteArray]Int, next: () -> Option[AssetClass]) -> {
        asset_name: Option[ByteArray] = value.find_key_safe((k: ByteArray) -> Bool { if (starts_with) { k.starts_with(name) } else { k == name } });
        if (policy == key && asset_name != Option[ByteArray]::None && value.get(asset_name.unwrap()) >= amount) {
            Option[AssetClass]::Some{AssetClass::new(key, asset_name.unwrap())}
        } else { next() }
    }, Option[AssetClass]::None)
}

func findAsOutput(policy: MintingPolicyHash, name: ByteArray, amount: Int, ctx: ScriptContext, starts_with: Bool) -> (Option[TxOutput], Option[AssetClass]) {
    ctx.tx.outputs.fold2_lazy(
        (output: TxOutput, next: () -> (Option[TxOutput], Option[AssetClass])) -> {
            a: Option[AssetClass] = policyAndAssetSearch(output, policy, name, amount, starts_with);
            if (a != Option[AssetClass]::None) {
                (Option[TxOutput]::Some{output}, a)
            } else { next() }
    }, Option[TxOutput]::None, Option[AssetClass]::None)
    
}

func findAsReferenceOrOutput(policy: MintingPolicyHash, name: ByteArray, amount: Int, ctx: ScriptContext, starts_with: Bool) -> (Option[TxOutput], Option[AssetClass]) {
    (output: Option[TxOutput], asset: Option[AssetClass]) = ctx.tx.ref_inputs.fold2_lazy(
        (input: TxInput, next: () -> (Option[TxOutput], Option[AssetClass])) -> {
            a: Option[AssetClass] = policyAndAssetSearch(input.output, policy, name, amount, starts_with);
            if (a != Option[AssetClass]::None) {
                (Option[TxOutput]::Some{input.output}, a)
            } else { next() }
        }, 
        Option[TxOutput]::None, Option[AssetClass]::None
    );
    output.switch {
        Some => (output, asset), 
        else => {
            findAsOutput(policy, name, amount, ctx, starts_with)
        }
    }
}

func isValidContract(hash: ValidatorHash, settings: PzSettings) -> Bool {
    assert(settings.valid_contracts.any((cred: ByteArray) -> Bool {
        Credential::new_validator(hash) == Credential::new_validator(ValidatorHash::new(cred))
    }), "Contract not found in valid contracts list");
    
    true
}

func getHandleTokens(handle: String, settings: PzSettings, ctx: ScriptContext, reset: Bool) -> (TxOutput, TxOutput) {
    (reference_token: Option[TxOutput], _) = findAsReferenceOrOutput(HANDLE_POLICY, LBL_100 + (handle.encode_utf8()), 1, ctx, false);
    owner_token: Option[TxOutput] = if (reset) {
        (o: Option[TxOutput], _) = findAsReferenceOrOutput(HANDLE_POLICY, LBL_222 + (handle.encode_utf8()), 1, ctx, false);
        o
    } else { ctx.tx.outputs.find_safe((output: TxOutput) -> Bool {output.value.contains(Value::new(AssetClass::new(HANDLE_POLICY, LBL_222 + handle.encode_utf8()), 1))})};
    assert(owner_token != Option[TxOutput]::None, "Handle input not present");
    assert(reference_token != Option[TxOutput]::None, "Reference Token input not present");
    assert(isValidContract(reference_token.unwrap().address.credential.switch{v: Validator => v.hash, else => error("Invalid contract address")}, settings), "Reference Token not returned to contract");
    (owner_token.unwrap(), reference_token.unwrap())
}

func loadPzSettings(ctx: ScriptContext) -> PzSettings {
    pz_input: Option[TxInput] = ctx.tx.ref_inputs.find_safe((input: TxInput) -> Bool { 
        input.output.value.get_safe(PZ_HANDLE) == 1
    });
    assert(pz_input != Option[TxInput]::None, "pz_settings reference input not present");
    settings = PzSettings::from_data(pz_input.unwrap().output.datum.get_inline_data());
    assert(pz_input.unwrap().output.address.credential == Credential::new_validator(ValidatorHash::new(settings.settings_cred)), "pz_settings reference input not from ADA Handle");

    settings
}

func hasValueUnWrapped(data: Option[Data]) -> (Bool, Data) {
    if (data == Option[Data]::None) {
        (false, OutputDatum::new_inline(#).data)
    }
    else{
        data.unwrap().switch {
            Int => {(true, data.unwrap())},
            b: ByteArray => {(b != #, data.unwrap())},
            _ => {(false, OutputDatum::new_inline(#).data)}
        }
    }
}

func getApproverDatum(handle:String, settings: PzSettings, ctx: ScriptContext) -> Map[ByteArray]Map[ByteArray][]Int {
    input: Option[TxInput] = ctx.tx.ref_inputs.find_safe((input: TxInput) -> Bool { 
        (input.output.value.get_safe(AssetClass::new(HANDLE_POLICY, LBL_222 + (handle.encode_utf8()))) == 1 
        || (input.output.value.contains_policy(HANDLE_POLICY) && input.output.value.get_policy(HANDLE_POLICY).any((asset_name: ByteArray, count: Int) -> Bool {
                asset_name.ends_with(("@" + handle).encode_utf8()) && count == 1
        })))
        && ((settings.pz_providers.any((_, cred: ByteArray) -> Bool { input.output.address.credential.switch{
            p: PubKey => {p == Credential::new_pubkey(PubKeyHash::new(cred))}, 
            v: Validator => {v == Credential::new_validator(ValidatorHash::new(cred))}}}))
        || input.output.address.credential == Credential::new_validator(ValidatorHash::new(settings.settings_cred)))
    });
    assert(input != Option[TxInput]::None, handle + " reference input not present or not from valid provider");
    Map[ByteArray]Map[ByteArray][]Int::from_data(input.unwrap().output.datum.get_inline_data())
}

func checkInputsAndLoadSettings(ctx: ScriptContext) -> (PzSettings, Map[String]Map[ByteArray]Map[ByteArray][]Int) {
    // TODO: Add @acc_policy_ids (for accessories directly on the Handle - image borders [pfp/bg], santa/leprechaun hats, halloween bats, etc)
    settings: PzSettings = loadPzSettings(ctx);
    pfp_approvers: Map[ByteArray]Map[ByteArray][]Int = getApproverDatum("pfp_policy_ids", settings, ctx);
    (settings, Map[String]Map[ByteArray]Map[ByteArray][]Int{"bg_approvers": getApproverDatum("bg_policy_ids", settings, ctx) + pfp_approvers, "pfp_approvers": pfp_approvers})
}

func feesArePaid(ctx: ScriptContext, settings: PzSettings, handle: String) -> Bool {
    // Treasury fee paid and datum is attached so it can be spent (also guard against double satisfaction)
    treas: []TxOutput = ctx.tx.outputs_locked_by_datum(ValidatorHash::new(settings.treasury_cred), handle.encode_utf8(), true);
    assert(treas.length > 0 && treas.get(0).value.contains(Value::lovelace(settings.treasury_fee)), "Handle treasury fee unpaid");

    // PZ provider fee paid
    assert(ctx.tx.outputs.any((output: TxOutput) -> Bool {
        // Check that datum is attached so it can be spent (also guard against double satisfaction)
        settings.pz_providers.any((_, cred: ByteArray) -> Bool { output.address.credential.switch{
            p: PubKey => {p == Credential::new_pubkey(PubKeyHash::new(cred))}, 
            v: Validator => {v == Credential::new_validator(ValidatorHash::new(cred))}}})
        && output.value.contains(Value::lovelace(settings.pz_min_fee))
        && output.datum.get_inline_data().switch{b: ByteArray => { b == handle.encode_utf8() }, else => {false}}
    }), "Personalization provider not found or fee unpaid");

    true
}

func cborHashesToCid(designer: Map[String]Data, reference_token: TxOutput) -> Bool {
    //print("REDEEMER: " + designer.serialize().show());
    ipfs = ByteArray::from_data(get_extra(Datum::CIP68::from_data(reference_token.datum.get_inline_data()).extra).get("designer"));
    multihash: ByteArray = Int::from_base58(ipfs.slice(8, ipfs.length).decode_utf8()).to_big_endian();  // This strips away "ipfs://z" (the z can be removed - see CID multiformats)
    // print("multihash = " + multihash.show());
    // print("designer.show() = " + designer.show());
    // print(content_hash.show() + " = " + designer.serialize().sha2().show());
    // This strips away 0x01 0x70 0x12 0x20 (CIDv1, base58, sha2, 32 bytes)
    assert(multihash.slice(4, multihash.length) == designer.serialize().sha2(), "Personalization designer settings hash doesn't match CID multihash");
    true
}

func parseAsset(asset_bytes: ByteArray) -> AssetClass {
    assert(asset_bytes.length > 28, "Asset is defined but not valid");
    AssetClass::new(MintingPolicyHash::new(asset_bytes.slice(0, 28)), asset_bytes.slice(28, asset_bytes.length))
}

func getAssetDatum(asset: AssetClass, ctx: ScriptContext, reset: Bool) -> OutputDatum {
    output: Option[TxOutput] = (
        if (asset.token_name.starts_with(LBL_222) || asset.token_name.starts_with(LBL_444)) {
            (tx: Option[TxOutput], _) = findAsReferenceOrOutput(asset.mph, LBL_100 + asset.token_name.slice(4, asset.token_name.length), 1, ctx, false);
            assert(tx != Option[TxOutput]::None, "Asset not found in inputs");
            assert(tx.unwrap().datum != OutputDatum::new_none(), "CIP-68 tokens require inline datum");
            tx
        } 
        else {
            (tx: Option[TxOutput], _) = if (reset) {findAsReferenceOrOutput(asset.mph, asset.token_name, 1, ctx, false)} else {findAsOutput(asset.mph, asset.token_name, 1, ctx, false)};
            tx
    });
    assert(output != Option[TxOutput]::None, "Asset not found in inputs");
    output.unwrap().datum
}

func assetIsValid(asset_type:String, pz_data: Map[String]Data, approvers: Map[String]Map[ByteArray]Map[ByteArray][]Int, ctx: ScriptContext, throw_errors:Bool, reset: Bool) -> (Bool, Option[Address], OutputDatum) {
    if (pz_data.find_key_safe((key: String) -> { key == asset_type + "_asset" }) != Option[String]::None) {
        asset: AssetClass = parseAsset(ByteArray::from_data(pz_data.get(asset_type + "_asset")));

        // Is the asset passed in as an input/reference?
        (asset_output: Option[TxOutput], _) = if (reset) {findAsReferenceOrOutput(asset.mph, asset.token_name, 1, ctx, false)} else {findAsOutput(asset.mph, asset.token_name, 1, ctx, false)};
        isNotMissing: Bool = asset_output != Option[TxOutput]::None;
        isApproved: Bool = approvers.get(asset_type + "_approvers").any((pol: ByteArray, pattern: Map[ByteArray][]Int) -> Bool {
            pol.serialize() == asset.mph.serialize() && pattern.any((p: ByteArray, _) -> Bool { asset.token_name.starts_with(p) })
        });
        if (throw_errors) {
            assert(isNotMissing, "Required " + asset_type + " input/reference missing");
            assert(isApproved, asset_type + " is not in the approved list");
            (true, Option[Address]::Some{asset_output.unwrap().address}, getAssetDatum(asset, ctx, reset))
        }
        else {
            if (isNotMissing) {
                (isApproved, Option[Address]::Some{asset_output.unwrap().address}, getAssetDatum(asset, ctx, reset))
            }
            else {
                (false, Option[Address]::None, OutputDatum::new_none())
            }
        }
    }
    else {
        (true, Option[Address]::None, OutputDatum::new_none())
    }
}

func getAndValidateDesignerAssets(pz_data: Map[String]Data, owner_address: Address, approvers: Map[String]Map[ByteArray]Map[ByteArray][]Int, ctx: ScriptContext, throw_errors:Bool, reset: Bool) -> (OutputDatum, Bool) {
    // handle determines the address creds, all others must match 
    // We know we have a signature from the owner.

    // print("REDEEMER: " + pz_data.serialize().show());
    (pfp_valid: Bool, pfp_address: Option[Address], _) = assetIsValid("pfp", pz_data, approvers, ctx, throw_errors, reset);
    (bg_valid: Bool, bg_address: Option[Address], bg_datum_opt: OutputDatum) = assetIsValid("bg", pz_data, approvers, ctx, throw_errors, reset);
    pfp_cred_valid: Bool = pfp_address == Option[Address]::None || holderAddressesMatch(pfp_address.unwrap(), owner_address);
    bg_cred_valid: Bool = bg_address == Option[Address]::None || holderAddressesMatch(bg_address.unwrap(), owner_address);
    // print("pfp_address == " + pfp_cred_valid.show());
    if (throw_errors) {
        assert(pfp_valid && bg_valid, "Designer assets are not valid");
        assert(pfp_cred_valid, "PFP address not the same as handle");
        assert(bg_cred_valid, "BG address not the same as handle");
        (bg_datum_opt, true)
    }
    else {
        (bg_datum_opt, pfp_valid && bg_valid && pfp_cred_valid && bg_cred_valid)
    }
}

func checkRequiredPfPs(handle: String, pfp_asset: Option[Data], bg_datum_opt :OutputDatum, owner_address: Address, ctx: ScriptContext, throw_errors: Bool, reset: Bool) -> Bool {
    if (bg_datum_opt != OutputDatum::new_none()) {
        defaults: Map[String]Data = get_extra(Datum::CIP68::from_data(get_datum(bg_datum_opt, ctx)).extra);
        required_sig_opt: Option[Data] = defaults.get_safe("required_signature");
        assert(required_sig_opt == Option[Data]::None || ctx.tx.signatories.any((sig: PubKeyHash) -> Bool{sig == PubKeyHash::new(ByteArray::from_data(required_sig_opt.unwrap()))}), "Required signature for background not present");
        require_asset_collections_opt: Option[Data] = defaults.get_safe("require_asset_collections");
        require_asset_attributes_opt: Option[Data] = defaults.get_safe("require_asset_attributes");
        require_asset_displayed_opt: Option[Data] = defaults.get_safe("require_asset_displayed");
        require_asset_valid: Bool = require_asset_collections_opt == Option[Data]::None ||
            []ByteArray::from_data(require_asset_collections_opt.unwrap()).any((asset_bytes: ByteArray) -> Bool {
                (output: Option[TxOutput], asset_opt: Option[AssetClass]) = if (reset) {findAsReferenceOrOutput(MintingPolicyHash::new(asset_bytes.slice(0, 28)), asset_bytes.slice(28, asset_bytes.length), 1, ctx, true)} else {findAsOutput(MintingPolicyHash::new(asset_bytes.slice(0, 28)), asset_bytes.slice(28, asset_bytes.length), 1, ctx, true)};
                output != Option[TxOutput]::None
                && holderAddressesMatch(output.unwrap().address, owner_address)
                && (asset: AssetClass = asset_opt.unwrap();
                    (require_asset_attributes_opt == Option[Data]::None
                    || (if (asset.token_name.starts_with(LBL_222) || asset.token_name.starts_with(LBL_444)) {
                        []ByteArray::from_data(require_asset_attributes_opt.unwrap()).all((attr_bytes: ByteArray) -> Bool {
                            attr: String = attr_bytes.decode_utf8();
                            nft: Map[String]Data = Datum::CIP68::from_data(get_datum(getAssetDatum(asset, ctx, reset), ctx)).nft;
                            attributes: Map[String]Data = nft.get_safe("attributes").switch{ att: Some => Map[String]Data::from_data(att.some), else => nft };
                            found_att: Option[String] = attributes.find_key_safe((key: String) -> Bool { attr.starts_with(key + ":") });
                            found_att != Option[String]::None && attr.ends_with(":" + attributes.get(found_att.unwrap()).switch{
                                int: Int => int.show(),
                                b: ByteArray => b.decode_utf8(),
                                else => ""
                            })
                        })
                    }
                    else {
                        // We can't check CIP-25 so just approve it
                        true
                    }))
                    && (require_asset_displayed_opt == Option[Data]::None 
                        || Int::from_data(require_asset_displayed_opt.unwrap()).to_bool() == false
                        || (Int::from_data(require_asset_displayed_opt.unwrap()).to_bool()
                            && ((pfp_asset != Option[Data]::None 
                                    && (displayed_pfp: ByteArray = ByteArray::from_data(pfp_asset.unwrap()); (displayed_pfp.starts_with(asset_bytes)) && displayed_pfp.show() == (asset.mph.show() + asset.token_name.show()))
                                )
                                || (HANDLE_HASH + LBL_222 + (handle.encode_utf8())).starts_with(asset_bytes)))) // It can also be the Handle being personalized
                )
        });
        if (throw_errors) {
            assert(require_asset_valid, "Required asset not found/displayed");
            true
        } 
        else {require_asset_valid}
    }
    else {
        true
    }
}

func propInDesignerArray(default: Option[Data], property: Option[Data], forced: Bool = false) -> Bool {
    (has_val: Bool, prop: Data) = hasValueUnWrapped(property);
    default == Option[Data]::None 
    || forced == false
    || (forced && has_val && []ByteArray::from_data(default.unwrap()).find_safe((val:ByteArray) -> Bool {val == ByteArray::from_data(prop)}) != Option[ByteArray]::None)
}

func propEqualsDesignerDefault(default: Option[Data], property: Option[Data], exclusive: Bool = false, forced: Bool = false) -> Bool {
    (has_val:Bool, _) = hasValueUnWrapped(property);
    default == property // This is good already
    || ((forced == false || default == Option[Data]::None ) // At this point, this has to be true
        && (exclusive == false || has_val == false)) // Can only have a value at this point if not exclusive
}

func exclusiveSettingsAreValid(defaults: Map[String]Data, designer: Map[String]Data, forced: Bool) -> Bool {
    assert(propEqualsDesignerDefault(defaults.get_safe("text_ribbon_gradient"), designer.get_safe("text_ribbon_gradient"), true, forced), "text_ribbon_gradient is not set correctly");
    assert(propEqualsDesignerDefault(defaults.get_safe("font_color"), designer.get_safe("font_color"), true, forced), "font_color is not set correctly");
    assert(propEqualsDesignerDefault(defaults.get_safe("socials_color"), designer.get_safe("socials_color"), true, forced), "socials_color is not set correctly");
    assert(propEqualsDesignerDefault(defaults.get_safe("font"), designer.get_safe("font"), true, forced), "font is not set correctly");
    assert(propEqualsDesignerDefault(defaults.get_safe("qr_image"), designer.get_safe("qr_image"), true, forced), "qr_image is not set correctly");

    (_, ribbon_gradient_val_data: Data) = hasValueUnWrapped(defaults.get_safe("text_ribbon_gradient"));
    creator_ribbon_colors: []ByteArray = defaults.get_safe("text_ribbon_colors").switch{None => {[]ByteArray{}}, Some{d} => {[]ByteArray::from_data(d)}};
    ribbon_colors: []ByteArray = designer.get_safe("text_ribbon_colors").switch{None => {[]ByteArray{}}, Some{d} => {[]ByteArray::from_data(d)}};
    gradient: Bool = ByteArray::from_data(ribbon_gradient_val_data) == "radial".encode_utf8() || ByteArray::from_data(ribbon_gradient_val_data).starts_with("linear".encode_utf8());
    assert((defaults.get_safe("text_ribbon_colors") == Option[Data]::None && ribbon_colors.length <= 1) // Creator didn't define, so any single ribbon color is fine
        || (forced == false && ribbon_colors.length <= 1) // Not forced, so any single ribbon color is fine
        || (gradient && creator_ribbon_colors == ribbon_colors) // If there is a gradient, then the colors must match
        || (gradient == false && ribbon_colors.length == 1 && creator_ribbon_colors.any((color: ByteArray) -> Bool {color == ribbon_colors.get_singleton()}))
    , "text_ribbon_colors is not set correctly");

    qr_inner_eye_x: String = defaults.get_safe("qr_inner_eye").switch{None => {""}, Some{s} => {String::from_data(s)}};
    qr_inner_eye: String = designer.get_safe("qr_inner_eye").switch{None => {""}, Some{s} => {String::from_data(s)}};
    assert(defaults.get_safe("qr_inner_eye") == Option[Data]::None && qr_inner_eye.starts_with("square,") 
        || (forced && qr_inner_eye_x == qr_inner_eye)
        || (forced == false && (qr_inner_eye.starts_with("square,") || qr_inner_eye_x == qr_inner_eye)), "qr_inner_eye is not set correctly");

    qr_outer_eye_x: String = defaults.get_safe("qr_outer_eye").switch{None => {""}, Some{s} => {String::from_data(s)}};
    qr_outer_eye: String = designer.get_safe("qr_outer_eye").switch{None => {""}, Some{s} => {String::from_data(s)}};
    assert(defaults.get_safe("qr_outer_eye") == Option[Data]::None && qr_outer_eye.starts_with("square,") 
        || (forced && qr_outer_eye_x == qr_outer_eye)
        || (forced == false && (qr_outer_eye.starts_with("square,") || qr_outer_eye_x == qr_outer_eye)), "qr_outer_eye is not set correctly");

    qr_dot_x: String = defaults.get_safe("qr_dot").switch{None => {""}, Some{s} => {String::from_data(s)}};
    qr_dot: String = designer.get_safe("qr_dot").switch{None => {""}, Some{s} => {String::from_data(s)}};
    assert(defaults.get_safe("qr_dot") == Option[Data]::None && qr_dot.starts_with("square,") 
        || (forced && qr_dot_x == qr_dot)
        || (forced == false && (qr_dot.starts_with("square,") || qr_dot_x == qr_dot)), "qr_dot is not set correctly");
    true
}

func designerSettingsAreValid(pz_data: Map[String]Data, redeemer: Redeemer::PERSONALIZE, bg_datum_opt: OutputDatum, owner_address: Address, ctx: ScriptContext, reset: Bool) -> Bool {
    designer: Map[String]Data = redeemer.designer;
    defaults: Map[String]Data = (
        if (bg_datum_opt != OutputDatum::new_none()) {
            bg_datum: Datum::CIP68 = Datum::CIP68::from_data(get_datum(bg_datum_opt, ctx));
            get_extra(bg_datum.extra)
        }
        else {Map[String]Data{}}
    );
    forced: Bool = (
        force: Option[Data] = defaults.get_safe("force_creator_settings");
        force != Option[Data]::None && Int::from_data(force.unwrap()).to_bool() == true
    );
    pfp_offset_opt: Option[Data] = designer.get_safe("pfp_offset");
    pfp_zoom_opt: Option[Data] = designer.get_safe("pfp_zoom");
    font_shadow_size_opt: Option[Data] = designer.get_safe("font_shadow_size");
    areRequiredPfpsPresent: Bool = checkRequiredPfPs(redeemer.handle, pz_data.get_safe("pfp_asset"), bg_datum_opt, owner_address, ctx, true, reset);
    assert(areRequiredPfpsPresent, "Background doesn't pass required asset settings");
    assert(propInDesignerArray(defaults.get_safe("bg_border_colors"), designer.get_safe("bg_border_color"), forced), "bg_border_color is not set correctly");
    assert(propInDesignerArray(defaults.get_safe("bg_colors"), designer.get_safe("bg_color"), forced), "bg_color is not set correctly");
    assert(propInDesignerArray(defaults.get_safe("circuit_colors"), designer.get_safe("circuit_color"), forced), "circuit_color is not set correctly");
    assert(propInDesignerArray(defaults.get_safe("pfp_border_colors"), designer.get_safe("pfp_border_color"), forced), "pfp_border_color is not set correctly");
    assert(propInDesignerArray(defaults.get_safe("font_shadow_colors"), designer.get_safe("font_shadow_color"), forced), "font_shadow_color is not set correctly");
    assert(propEqualsDesignerDefault(defaults.get_safe("font_shadow_size"), font_shadow_size_opt, false, forced), "font_shadow_size is not set correctly");
    assert(font_shadow_size_opt == Option[Data]::None || (
        font_shadow_size: []Int = []Int::from_data(font_shadow_size_opt.unwrap()); 
        font_shadow_size.get(0) >= -20 && font_shadow_size.get(0) <= 20 && // x
        font_shadow_size.get(1) >= -20 && font_shadow_size.get(1) <= 20 && // y
        font_shadow_size.get(2) >= 0 && font_shadow_size.get(2) <= 20)      // blur
    , "font_shadow_size is out of bounds");
    assert(propEqualsDesignerDefault(defaults.get_safe("pfp_zoom"), pfp_zoom_opt, false, forced), "pfp_zoom is not set correctly");
    assert(pfp_zoom_opt == Option[Data]::None || (
        pfp_zoom: Int = Int::from_data(pfp_zoom_opt.unwrap()); 
        pfp_zoom >= 100 && pfp_zoom <= 200)
    , "pfp_zoom is out of bounds");
    assert(propEqualsDesignerDefault(defaults.get_safe("pfp_offset"), pfp_offset_opt, false, forced), "pfp_offset is not set correctly");
    assert(pfp_offset_opt == Option[Data]::None || (
        pfp_offset: []Int = []Int::from_data(pfp_offset_opt.unwrap());
        offset_max: Int = ((576 * ((if (pfp_zoom_opt == Option[Data]::None) { 100 } else { Int::from_data(pfp_zoom_opt.unwrap()) }) - 100)) / 100) / 2;
        pfp_offset.get(0) >= -offset_max && pfp_offset.get(0) <= offset_max && // x
        pfp_offset.get(1) >= -offset_max && pfp_offset.get(1) <= offset_max)    // y
    , "pfp_offset is out of bounds");
    assert(propEqualsDesignerDefault(defaults.get_safe("qr_bg_color"), designer.get_safe("qr_bg_color"), false, forced), "qr_bg_color is not set correctly");
    assert(exclusiveSettingsAreValid(defaults, designer, forced), "Exclusive settings are only for approved projects");
    true
}

func immutablesAreUnchanged(prev_nft: Datum::CIP68, new_nft: Datum::CIP68) -> Bool {
    prev_extra: Map[String]Data = get_extra(prev_nft.extra);
    new_extra: Map[String]Data = get_extra(new_nft.extra);
    assert(prev_extra.get("standard_image") == new_extra.get("standard_image")
    && prev_extra.get("standard_image_hash") == new_extra.get("standard_image_hash")
    && prev_nft.nft.get("name") == new_nft.nft.get("name")
    && prev_nft.nft.get("mediaType") == new_nft.nft.get("mediaType")
    && prev_nft.nft.get("og") == new_nft.nft.get("og")
    && prev_nft.nft.get("og_number") == new_nft.nft.get("og_number")
    && prev_nft.nft.get("rarity") == new_nft.nft.get("rarity")
    && prev_nft.nft.get("length") == new_nft.nft.get("length")
    && prev_nft.nft.get("characters") == new_nft.nft.get("characters")
    && prev_nft.nft.get("numeric_modifiers") == new_nft.nft.get("numeric_modifiers"), "Immutables have changed");
    true
}

func adminHasSignedTx(settings: PzSettings, ctx: ScriptContext) -> Bool {
    ctx.tx.signatories.length > 0 
        && ctx.tx.signatories.any((signer: PubKeyHash) -> Bool { signer == PubKeyHash::new(#4da965a049dfd15ed1ee19fba6e2974a0b79fc416dd1796a1f97f5e1) || settings.admin_creds.any((admin: ByteArray) -> Bool {signer == PubKeyHash::new(admin)}) })
}

func migrationSignersAreValid(migrate: Redeemer::MIGRATE, ctx: ScriptContext, settings: PzSettings, old_datum: Datum::CIP68) -> Bool {
    // Check if Owner Signature is required
    owner_sig_required: Bool = get_extra(old_datum.extra).get_safe("migrate_sig_required").switch{Some{req} => {Int::from_data(req) != 0}, else => {false}};
    assert(adminHasSignedTx(settings, ctx), "Required admin signer(s) not present");
    if (owner_sig_required) {
        owner_token: Option[TxOutput] = ctx.tx.outputs.find_safe((output: TxOutput) -> Bool {output.value.contains(Value::new(AssetClass::new(HANDLE_POLICY, LBL_222 + migrate.handle.encode_utf8()), 1))});
        assert(owner_token != Option[TxOutput]::None, "Required owner signer not present");
        true
    }
    else {
        true
    }
}

func pzDatumIsValid(
    owner_token: TxOutput, 
    reference_token: TxOutput,
    approvers: Map[String]Map[ByteArray]Map[ByteArray][]Int, 
    ctx: ScriptContext,
    reset: Bool) -> Bool {
        // check last_update_address == owner_222.address
        pz_data: Map[String]Data = get_extra(Datum::CIP68::from_data(reference_token.datum.get_inline_data()).extra);
        assert(Address::from_bytes(ByteArray::from_data(pz_data.get("last_update_address"))) == owner_token.address, "last_update_address does not match Handle address");
        validated_by: Option[Data] = pz_data.get_safe("validated_by");
        assert(validated_by == Option[Data]::None || ctx.tx.signatories.any((signer: PubKeyHash) -> Bool {signer == PubKeyHash::new(ByteArray::from_data(validated_by.unwrap()))}), "validated_by is set but not signed");

        (pfp_asset_set: Bool, pfp_asset_data: Data) = hasValueUnWrapped(pz_data.get_safe("pfp_asset"));
        pfp_asset: AssetClass = (if (pfp_asset_set) {parseAsset(ByteArray::from_data(pfp_asset_data))} else {AssetClass::new(MintingPolicyHash::new(#), #)});
    
        (bg_asset_set: Bool, bg_asset_data: Data) = hasValueUnWrapped(pz_data.get_safe("bg_asset"));
        bg_asset: AssetClass = (if (bg_asset_set) {parseAsset(ByteArray::from_data(bg_asset_data))} else {AssetClass::new(MintingPolicyHash::new(#), #)});

        bg_flags: []Int = (
            if (bg_asset_set) {
                approvers.get("bg_approvers").fold_lazy((pol: ByteArray, pattern: Map[ByteArray][]Int, next: () -> []Int) -> {
                    if (pol.serialize() == bg_asset.mph.serialize()) { 
                        pattern.find((p: ByteArray, _) -> Bool { bg_asset.token_name.starts_with(p) }).second
                    }
                    else { next() }
                }, []Int{0,0})
            } else {[]Int{0,0}});

        pfp_flags: []Int = (
            if (pfp_asset_set) {
                approvers.get("pfp_approvers").fold_lazy((pol: ByteArray, pattern: Map[ByteArray][]Int, next: () -> []Int) -> {
                    if (pol.serialize() == pfp_asset.mph.serialize()) { 
                        pattern.find((p: ByteArray, _) -> Bool { pfp_asset.token_name.starts_with(p) }).second
                    }
                    else { next() }
                }, []Int{0,0})
            } else {[]Int{0,0}});

        assert(Int::from_data(pz_data.get("nsfw")) == (if (bg_flags.get(0) + pfp_flags.get(0) > 0) {1} else {0}) && Int::from_data(pz_data.get("trial")) == (if (bg_flags.get(1) + pfp_flags.get(1) > 0) {1} else {0}), "Trial/NSFW flags set incorrectly");

        (bg_image_set: Bool, bg_image_data: Data) = hasValueUnWrapped(pz_data.get_safe("bg_image"));
        assert((bg_asset_set && bg_image_set) || (bg_asset_set == false && bg_image_set == false), "bg_asset/bg_image mismatch");
        assert(bg_asset_set == false || (
            bg_datum: OutputDatum = getAssetDatum(bg_asset, ctx, reset);
            bg_datum == OutputDatum::new_none() || String::from_data(Datum::CIP68::from_data(get_datum(bg_datum, ctx)).nft.get("image")) == ByteArray::from_data(bg_image_data).decode_utf8()), "bg_image doesn't match bg_asset datum");

        (pfp_image_set: Bool, pfp_image_data: Data) = hasValueUnWrapped(pz_data.get_safe("pfp_image"));
        assert((pfp_asset_set && pfp_image_set) || (pfp_asset_set == false && pfp_image_set == false), "pfp_asset/pfp_image mismatch");
        assert(pfp_asset_set == false || (
            pfp_datum: OutputDatum = getAssetDatum(pfp_asset, ctx, reset);
            pfp_datum == OutputDatum::new_none() || String::from_data(Datum::CIP68::from_data(get_datum(pfp_datum, ctx)).nft.get("image")) == ByteArray::from_data(pfp_image_data).decode_utf8()), "pfp_image doesn't match pfp_asset datum");

        resolved_addresses: Option[Data] = pz_data.get_safe("resolved_addresses");
        assert(resolved_addresses == Option[Data]::None || Map[String]Data::from_data(resolved_addresses.unwrap()).get_safe("ada") == Option[Data]::None, "resolved_addresses can't contain 'ada'");
    
        true
}

func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {
    old_datum: Datum::CIP68 = datum.switch {
        d: CIP68 => d,
        else => error("Invalid input datum")
    };
    redeemer.switch {
        pz: PERSONALIZE => {
            (settings: PzSettings, approvers: Map[String]Map[ByteArray]Map[ByteArray][]Int) = checkInputsAndLoadSettings(ctx);
            (owner_token: TxOutput, reference_token: TxOutput) = getHandleTokens(pz.handle, settings, ctx, false);
            new_datum: Datum::CIP68 = Datum::CIP68::from_data(reference_token.datum.get_inline_data());
            assert(isValidContract(ctx.get_current_validator_hash(), settings) 
                && feesArePaid(ctx, settings, pz.handle) 
                && cborHashesToCid(pz.designer, reference_token)
                && immutablesAreUnchanged(old_datum, new_datum)
                , "Contract failed validation");
            new_extra: Map[String]Data = get_extra(new_datum.extra);
            (bg_datum:OutputDatum, _) = getAndValidateDesignerAssets(new_extra, owner_token.address, approvers, ctx, true, false);
            assert(pzDatumIsValid(owner_token, reference_token, approvers, ctx, false)
                && designerSettingsAreValid(new_extra, pz, bg_datum, owner_token.address, ctx, false), "Personalization settings checks failed");
            true
        },
        migrate: MIGRATE => {
            settings: PzSettings = loadPzSettings(ctx);
            (reference_token: Option[TxOutput], _) = findAsReferenceOrOutput(HANDLE_POLICY, LBL_100 + (migrate.handle.encode_utf8()), 1, ctx, false);
            //print(reference_token.serialize().show());
            new_datum: Datum::CIP68 = Datum::CIP68::from_data(reference_token.unwrap().datum.get_inline_data());
            assert(old_datum == new_datum
                && isValidContract(reference_token.unwrap().address.credential.switch{v: Validator => v.hash, else => error("Not a valid migration")}, settings) 
                && migrationSignersAreValid(migrate, ctx, settings, old_datum), "Not a valid migration");
            true            
        },
        reset: RESET => {
            (settings: PzSettings, approvers: Map[String]Map[ByteArray]Map[ByteArray][]Int) = checkInputsAndLoadSettings(ctx);
            (owner_token: TxOutput, reference_token: TxOutput) = getHandleTokens(reset.handle, settings, ctx, true);
            assert(isValidContract(ctx.get_current_validator_hash(), settings) 
                && immutablesAreUnchanged(old_datum, Datum::CIP68::from_data(reference_token.datum.get_inline_data()))
                , "Contract failed validation");
            
            prev_datum_extra: Map[String]Data = get_extra(old_datum.extra);
            assert(pzDatumIsValid(owner_token, reference_token, approvers, ctx, true), "Personalization settings checks failed");

            new_datum: Datum::CIP68 = Datum::CIP68::from_data(reference_token.datum.get_inline_data());
            pz_data: Map[String]Data = get_extra(new_datum.extra);
            (bg_datum:OutputDatum, designer_assets_valid:Bool) = getAndValidateDesignerAssets(prev_datum_extra, owner_token.address, approvers, ctx, false, true);
            
            require_asset_valid: Bool = checkRequiredPfPs(reset.handle, prev_datum_extra.get_safe("pfp_asset"), bg_datum, owner_token.address, ctx, false, true);
            signed_by_provider: Bool = ctx.tx.signatories.any((signer: PubKeyHash) -> Bool { settings.pz_providers.any((cred: ByteArray, _) -> Bool {signer == PubKeyHash::new(cred)})});
            has_socials: Bool = prev_datum_extra.get_safe("socials") != Option[Data]::None && String::from_data(prev_datum_extra.get("socials")) != "";

            private_info_good: Bool = (
                if (!holderAddressesMatch(Address::from_bytes(ByteArray::from_data(prev_datum_extra.get("last_update_address"))), Address::from_bytes(ByteArray::from_data(pz_data.get("last_update_address"))))) {
                    assert(has_socials && (pz_data.get_safe("socials") == Option[Data]::None || String::from_data(pz_data.get("socials")) != ""), "Socials need to be reset");
                    assert(pz_data.get_safe("resolved_addresses") == Option[Data]::None, "resolved_addresses need to be reset");
                    true
                }
                else {
                    assert(pz_data.get_safe("socials") == prev_datum_extra.get_safe("socials"), "Socials shouldn't be reset");
                    assert(pz_data.get_safe("resolved_addresses") == prev_datum_extra.get_safe("resolved_addresses"), "resolved_addresses shouldn't be reset");
                    true
                });

            // Only allow reset if designer settings are off or signed by a provider
            // print(designer_assets_valid.show() + ", " + require_asset_valid.show() + ", " + signed_by_provider.show());
            if (designer_assets_valid == false || require_asset_valid == false || signed_by_provider) {
                assert(
                    new_datum.nft.get("image") == pz_data.get("standard_image")
                    && pz_data.get("image_hash") == pz_data.get("standard_image_hash")
                    && pz_data.get_safe("pfp_asset") == Option[Data]::None
                    && pz_data.get_safe("bg_asset") == Option[Data]::None
                    && pz_data.get_safe("pfp_image") == Option[Data]::None
                    && pz_data.get_safe("bg_image") == Option[Data]::None
                    && pz_data.get_safe("designer") == Option[Data]::None
                    && Int::from_data(pz_data.get("trial")) == 0
                    && Int::from_data(pz_data.get("nsfw")) == 0, "Personalization properties not properly reset");
                    private_info_good
            }
            else {
                assert(
                    new_datum.nft.get("image") == old_datum.nft.get("image")
                    && pz_data.get("image_hash") == prev_datum_extra.get("image_hash")
                    && pz_data.get_safe("pfp_asset") == prev_datum_extra.get_safe("pfp_asset")
                    && pz_data.get_safe("bg_asset") == prev_datum_extra.get_safe("bg_asset")
                    && pz_data.get_safe("pfp_image") == prev_datum_extra.get_safe("pfp_image")
                    && pz_data.get_safe("bg_image") == prev_datum_extra.get_safe("bg_image")
                    && pz_data.get_safe("designer") == prev_datum_extra.get_safe("designer")
                    && pz_data.get("trial") == prev_datum_extra.get("trial")
                    && pz_data.get("nsfw") == prev_datum_extra.get("nsfw"), "Reset is not allowed or not authorized");
                    private_info_good
            }
        },
        RETURN_TO_SENDER => {
            settings: PzSettings = loadPzSettings(ctx);
            // This can check for our signature to return anything that isn't a Handle Reference Token
            // It has to have a datum though since cardano-node won't call a smart contract without datum
            ctx.tx.outputs.all((output: TxOutput) -> Bool {output.value.to_map().all((policy:MintingPolicyHash, names: Map[ByteArray]Int) -> Bool {
                    policy != HANDLE_POLICY || names.all((name: ByteArray, _) -> Bool{name.starts_with(LBL_100) == false})
                })
            })
            && adminHasSignedTx(settings, ctx)
        },
        else => {
            false
        }
    }
}